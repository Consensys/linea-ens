{
  "language": "Solidity",
  "sources": {
    "@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol": {
      "content": "pragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\n\n    /*\n     * @dev Returns the keccak-256 hash of a byte range.\n     * @param self The byte string to hash.\n     * @param offset The position to start hashing at.\n     * @param len The number of bytes to hash.\n     * @return The hash of the byte range.\n     */\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal.\n     * @param self The first bytes to compare.\n     * @param other The second bytes to compare.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two bytes are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first bytes to compare.\n     * @param offset The offset of self.\n     * @param len    The length of self.\n     * @param other The second bytes to compare.\n     * @param otheroffset The offset of the other string.\n     * @param otherlen    The length of the other string.\n     * @return The result of the comparison.\n     */\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        if (offset + len > self.length) {\n            revert OffsetOutOfBoundsError(offset + len, self.length);\n        }\n        if (otheroffset + otherlen > other.length) {\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\n        }\n\n        uint256 shortest = len;\n        if (otherlen < len) shortest = otherlen;\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint256 mask;\n                if (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }\n                int256 diff = int256(a & mask) - int256(b & mask);\n                if (diff != 0) return diff;\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @param len The number of bytes to compare\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal with offsets.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @param otherOffset The offset into the second byte range.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset\n    ) internal pure returns (bool) {\n        return\n            keccak(self, offset, self.length - offset) ==\n            keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /*\n     * @dev Compares a range of 'self' to all of 'other' and returns True iff\n     *      they are equal.\n     * @param self The first byte range to compare.\n     * @param offset The offset into the first byte range.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == offset + other.length &&\n            equals(self, offset, other, 0, other.length);\n    }\n\n    /*\n     * @dev Returns true if the two byte ranges are equal.\n     * @param self The first byte range to compare.\n     * @param other The second byte range to compare.\n     * @return True if the byte ranges are equal, false otherwise.\n     */\n    function equals(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == other.length &&\n            equals(self, 0, other, 0, self.length);\n    }\n\n    /*\n     * @dev Returns the 8-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 8 bits of the string, interpreted as an integer.\n     */\n    function readUint8(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /*\n     * @dev Returns the 16-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 16 bits of the string, interpreted as an integer.\n     */\n    function readUint16(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32-bit number at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bits of the string, interpreted as an integer.\n     */\n    function readUint32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /*\n     * @dev Returns the 32 byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytes20(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(\n                mload(add(add(self, 32), idx)),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\n            )\n        }\n    }\n\n    /*\n     * @dev Returns the n byte value at the specified index of self.\n     * @param self The byte string.\n     * @param idx The index into the bytes.\n     * @param len The number of bytes.\n     * @return The specified 32 bytes of the string.\n     */\n    function readBytesN(\n        bytes memory self,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /*\n     * @dev Copies a substring into a new byte string.\n     * @param self The byte string to copy from.\n     * @param offset The offset to start copying at.\n     * @param len The number of bytes to copy.\n     */\n    function substring(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /**\n     * @dev Decodes unpadded base32 data of up to one word in length.\n     * @param self The data to decode.\n     * @param off Offset into the string to start at.\n     * @param len Number of characters to decode.\n     * @return The decoded data, left aligned.\n     */\n    function base32HexDecodeWord(\n        bytes memory self,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /**\n     * @dev Finds the first occurrence of the byte `needle` in `self`.\n     * @param self The string to search\n     * @param off The offset to start searching at\n     * @param len The number of bytes to search\n     * @param needle The byte to search for\n     * @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n     */\n    function find(\n        bytes memory self,\n        uint256 off,\n        uint256 len,\n        bytes1 needle\n    ) internal pure returns (uint256) {\n        for (uint256 idx = off; idx < off + len; idx++) {\n            if (self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/ethregistrar/IBaseRegistrar.sol": {
      "content": "import \"../registry/ENS.sol\";\nimport \"./IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IBaseRegistrar is IERC721 {\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true if the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the new (multicoin) addr function.\n */\ninterface IAddressResolver {\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * Interface for the legacy (ETH-only) addr function.\n */\ninterface IAddrResolver {\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface IContentHashResolver {\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/IMetadataService.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface IMetadataService {\n    function uri(uint256) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\nimport \"../registry/ENS.sol\";\nimport \"../ethregistrar/IBaseRegistrar.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"./IMetadataService.sol\";\nimport \"./INameWrapperUpgrade.sol\";\n\nuint32 constant CANNOT_UNWRAP = 1;\nuint32 constant CANNOT_BURN_FUSES = 2;\nuint32 constant CANNOT_TRANSFER = 4;\nuint32 constant CANNOT_SET_RESOLVER = 8;\nuint32 constant CANNOT_SET_TTL = 16;\nuint32 constant CANNOT_CREATE_SUBDOMAIN = 32;\nuint32 constant CANNOT_APPROVE = 64;\n//uint16 reserved for parent controlled fuses from bit 17 to bit 32\nuint32 constant PARENT_CANNOT_CONTROL = 1 << 16;\nuint32 constant IS_DOT_ETH = 1 << 17;\nuint32 constant CAN_EXTEND_EXPIRY = 1 << 18;\nuint32 constant CAN_DO_EVERYTHING = 0;\nuint32 constant PARENT_CONTROLLED_FUSES = 0xFFFF0000;\n// all fuses apart from IS_DOT_ETH\nuint32 constant USER_SETTABLE_FUSES = 0xFFFDFFFF;\n\ninterface INameWrapper is IERC1155 {\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/wrapper/INameWrapperUpgrade.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ~0.8.17;\n\ninterface INameWrapperUpgrade {\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/IAddrSetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ninterface IAddrSetter {\n    function setAddr(\n        bytes calldata name,\n        address _addr\n    ) external view returns (bytes memory result);\n}\n"
    },
    "contracts/IMetadataResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ninterface IMetadataResolver {\n    /*\n     * @notice Get metadata about the CCIP Resolver ENSIP 16 https://docs.ens.domains/ens-improvement-proposals/ensip-16-offchain-metadata\n     * @dev This function provides metadata about the CCIP Resolver, including its name, coin type, GraphQL URL, storage type, and encoded information.\n     * @param name The domain name in format (dnsEncoded)\n     * @return graphqlUrl The GraphQL URL used by the resolver\n     *\n     */\n    function metadata(\n        bytes calldata name\n    ) external view returns (string memory graphqlUrl);\n\n    event MetadataChanged(bytes name, string graphqlUrl);\n}\n"
    },
    "contracts/ITargetResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ninterface ITargetResolver {\n    function getTarget(\n        bytes memory name\n    ) external view returns (bytes32 node, address target);\n}\n"
    },
    "contracts/L1Resolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {EVMFetcher} from \"./linea-verifier/EVMFetcher.sol\";\nimport {EVMFetchTarget} from \"./linea-verifier/EVMFetchTarget.sol\";\nimport {IEVMVerifier} from \"./linea-verifier/IEVMVerifier.sol\";\nimport \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport {INameWrapper} from \"@ensdomains/ens-contracts/contracts/wrapper/INameWrapper.sol\";\nimport {BytesUtils} from \"@ensdomains/ens-contracts/contracts/dnssec-oracle/BytesUtils.sol\";\nimport {IAddrResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddrResolver.sol\";\nimport {IAddressResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IAddressResolver.sol\";\nimport {ITextResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\";\nimport {IContentHashResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IContentHashResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport {ITargetResolver} from \"./ITargetResolver.sol\";\nimport {IMetadataResolver} from \"./IMetadataResolver.sol\";\nimport {IAddrSetter} from \"./IAddrSetter.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\ncontract L1Resolver is\n    EVMFetchTarget,\n    ITargetResolver,\n    IMetadataResolver,\n    IExtendedResolver,\n    IAddrSetter,\n    ERC165\n{\n    using EVMFetcher for EVMFetcher.EVMFetchRequest;\n    using BytesUtils for bytes;\n    IEVMVerifier public immutable verifier;\n    ENS public immutable ens;\n    INameWrapper public immutable nameWrapper;\n    mapping(bytes32 => address) targets;\n    uint256 constant COIN_TYPE_ETH = 60;\n    uint256 constant RECORD_VERSIONS_SLOT = 0;\n    uint256 constant VERSIONABLE_ABIS_SLOT = 1;\n    uint256 constant VERSIONABLE_ADDRESSES_SLOT = 2;\n    uint256 constant VERSIONABLE_HASHES_SLOT = 3;\n    uint256 constant VERSIONABLE_TEXTS_SLOT = 10;\n    string public graphqlUrl;\n    uint256 public l2ChainId;\n\n    event TargetSet(bytes name, address target);\n\n    function isAuthorised(bytes32 node) internal view returns (bool) {\n        // TODO: Add support for\n        // trustedETHController\n        // trustedReverseRegistrar\n        // isApprovedForAll\n        // isApprovedFor\n        address owner = ens.owner(node);\n        if (owner == address(nameWrapper)) {\n            owner = nameWrapper.ownerOf(uint256(node));\n        }\n        return owner == msg.sender;\n    }\n\n    /**\n     * @dev EIP-5559 - Error to raise when mutations are being deferred to an L2.\n     * @param chainId Chain ID to perform the deferred mutation to.\n     * @param contractAddress Contract Address at which the deferred mutation should transact with.\n     */\n    error StorageHandledByL2(uint256 chainId, address contractAddress);\n\n    /**\n     * @param _verifier     The chain verifier address\n     * @param _ens          The ENS registry address\n     * @param _nameWrapper  The ENS name wrapper address\n     * @param _graphqlUrl   The offchain/l2 graphql endpoint url\n     * @param _l2ChainId    The chainId at which the resolver resolves data from\n     */\n    constructor(\n        IEVMVerifier _verifier,\n        ENS _ens,\n        INameWrapper _nameWrapper,\n        string memory _graphqlUrl,\n        uint256 _l2ChainId\n    ) {\n        require(\n            address(_nameWrapper) != address(0),\n            \"Name Wrapper address must be set\"\n        );\n        require(\n            address(_verifier) != address(0),\n            \"Verifier address must be set\"\n        );\n        require(address(_ens) != address(0), \"Registry address must be set\");\n        verifier = _verifier;\n        ens = _ens;\n        nameWrapper = _nameWrapper;\n        graphqlUrl = _graphqlUrl;\n        l2ChainId = _l2ChainId;\n    }\n\n    /**\n     * Set target address to verify aagainst\n     * @param name The encoded name to query.\n     * @param target The L2 resolver address to verify against.\n     */\n    function setTarget(bytes calldata name, address target) public {\n        (bytes32 node, ) = getTarget(name);\n        require(isAuthorised(node));\n        targets[node] = target;\n        emit TargetSet(name, target);\n        emit MetadataChanged(name, graphqlUrl);\n    }\n\n    /**\n     * @dev Returns the L2 target address that can answer queries for `name`.\n     * @param name DNS encoded ENS name to query\n     * @return node The node of the name\n     * @return target The L2 resolver address to verify against.\n     */\n    function getTarget(\n        bytes memory name\n    ) public view returns (bytes32 node, address target) {\n        return _getTarget(name, 0);\n    }\n\n    function _getTarget(\n        bytes memory name,\n        uint256 offset\n    ) private view returns (bytes32 node, address target) {\n        uint256 len = name.readUint8(offset);\n        node = bytes32(0);\n        if (len > 0) {\n            bytes32 label = name.keccak(offset + 1, len);\n            (node, target) = _getTarget(name, offset + len + 1);\n            node = keccak256(abi.encodePacked(node, label));\n            if (targets[node] != address(0)) {\n                return (node, targets[node]);\n            }\n        } else {\n            return (bytes32(0), address(0));\n        }\n        return (node, target);\n    }\n\n    /**\n     * @dev Resolve and verify a record stored in l2 target address. It supports subname by fetching target recursively to the nearlest parent.\n     * @param name DNS encoded ENS name to query\n     * @param data The actual calldata\n     * @return result result of the call\n     */\n    function resolve(\n        bytes calldata name,\n        bytes calldata data\n    ) external view returns (bytes memory result) {\n        (, address target) = _getTarget(name, 0);\n        bytes4 selector = bytes4(data);\n\n        if (selector == IAddrResolver.addr.selector) {\n            bytes32 node = abi.decode(data[4:], (bytes32));\n            return _addr(node, target);\n        }\n        if (selector == IAddressResolver.addr.selector) {\n            (bytes32 node, uint256 cointype) = abi.decode(\n                data[4:],\n                (bytes32, uint256)\n            );\n            return _addr(node, cointype, target);\n        }\n        if (selector == ITextResolver.text.selector) {\n            (bytes32 node, string memory key) = abi.decode(\n                data[4:],\n                (bytes32, string)\n            );\n            return bytes(_text(node, key, target));\n        }\n        if (selector == IContentHashResolver.contenthash.selector) {\n            bytes32 node = abi.decode(data[4:], (bytes32));\n            return _contenthash(node, target);\n        }\n    }\n\n    /**\n     * @dev Resolve and throws an EIP 3559 compliant error\n     * @param name DNS encoded ENS name to query\n     * @param _addr The actual calldata\n     * @return result result of the call\n     */\n    function setAddr(\n        bytes calldata name,\n        address _addr\n    ) external view returns (bytes memory result) {\n        (, address target) = _getTarget(name, 0);\n        _writeDeferral(target);\n    }\n\n    function _addr(\n        bytes32 node,\n        address target\n    ) private view returns (bytes memory) {\n        EVMFetcher\n            .newFetchRequest(verifier, target)\n            .getStatic(RECORD_VERSIONS_SLOT)\n            .element(node)\n            .getDynamic(VERSIONABLE_ADDRESSES_SLOT)\n            .ref(0)\n            .element(node)\n            .element(COIN_TYPE_ETH)\n            .fetch(this.addrCallback.selector, \"\"); // recordVersions\n    }\n\n    function addrCallback(\n        bytes[] memory values,\n        bytes memory\n    ) public pure returns (bytes memory) {\n        return abi.encode(address(bytes20(values[1])));\n    }\n\n    function _addr(\n        bytes32 node,\n        uint256 coinType,\n        address target\n    ) private view returns (bytes memory) {\n        EVMFetcher\n            .newFetchRequest(verifier, target)\n            .getStatic(RECORD_VERSIONS_SLOT)\n            .element(node)\n            .getDynamic(VERSIONABLE_ADDRESSES_SLOT)\n            .ref(0)\n            .element(node)\n            .element(coinType)\n            .fetch(this.addrCoinTypeCallback.selector, \"\");\n    }\n\n    function addrCoinTypeCallback(\n        bytes[] memory values,\n        bytes memory\n    ) public pure returns (bytes memory) {\n        return abi.encode(values[1]);\n    }\n\n    function _text(\n        bytes32 node,\n        string memory key,\n        address target\n    ) private view returns (bytes memory) {\n        EVMFetcher\n            .newFetchRequest(verifier, target)\n            .getStatic(RECORD_VERSIONS_SLOT)\n            .element(node)\n            .getDynamic(VERSIONABLE_TEXTS_SLOT)\n            .ref(0)\n            .element(node)\n            .element(key)\n            .fetch(this.textCallback.selector, \"\");\n    }\n\n    function textCallback(\n        bytes[] memory values,\n        bytes memory\n    ) public pure returns (bytes memory) {\n        return abi.encode(string(values[1]));\n    }\n\n    function _contenthash(\n        bytes32 node,\n        address target\n    ) private view returns (bytes memory) {\n        EVMFetcher\n            .newFetchRequest(verifier, target)\n            .getStatic(RECORD_VERSIONS_SLOT)\n            .element(node)\n            .getDynamic(VERSIONABLE_HASHES_SLOT)\n            .ref(0)\n            .element(node)\n            .fetch(this.contenthashCallback.selector, \"\");\n    }\n\n    function contenthashCallback(\n        bytes[] memory values,\n        bytes memory\n    ) public pure returns (bytes memory) {\n        return abi.encode(values[1]);\n    }\n\n    /**\n     * @notice Get metadata about the L1 Resolver\n     * @dev This function provides metadata about the L1 Resolver, including its name, coin type, GraphQL URL, storage type, and encoded information.\n     * @param name The domain name in format (dnsEncoded)\n     * @return graphqlUrl The GraphQL URL used by the resolver\n     */\n    function metadata(bytes calldata name) public view returns (string memory) {\n        return (graphqlUrl);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override returns (bool) {\n        return\n            interfaceId == type(IExtendedResolver).interfaceId ||\n            interfaceId == type(ITargetResolver).interfaceId ||\n            interfaceId == type(IMetadataResolver).interfaceId ||\n            interfaceId == type(IAddrSetter).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function _writeDeferral(address target) internal view {\n        revert StorageHandledByL2(l2ChainId, target);\n    }\n}\n"
    },
    "contracts/linea-verifier/EVMFetcher.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {IEVMVerifier} from \"./IEVMVerifier.sol\";\nimport {EVMFetchTarget} from \"./EVMFetchTarget.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\ninterface IEVMGateway {\n    function getStorageSlots(\n        address addr,\n        bytes32[] memory commands,\n        bytes[] memory constants\n    ) external pure returns (bytes memory witness);\n}\n\nuint8 constant FLAG_DYNAMIC = 0x01;\nuint8 constant OP_CONSTANT = 0x00;\nuint8 constant OP_BACKREF = 0x20;\nuint8 constant OP_END = 0xff;\n\n/**\n * @dev A library to facilitate requesting storage data proofs from contracts, possibly on a different chain.\n *      See l1-verifier/test/TestL1.sol for example usage.\n */\nlibrary EVMFetcher {\n    uint256 constant MAX_COMMANDS = 32;\n    uint256 constant MAX_CONSTANTS = 32; // Must not be greater than 32\n\n    using Address for address;\n\n    error TooManyCommands(uint256 max);\n    error CommandTooLong();\n    error InvalidReference(uint256 value, uint256 max);\n    error OffchainLookup(\n        address sender,\n        string[] urls,\n        bytes callData,\n        bytes4 callbackFunction,\n        bytes extraData\n    );\n\n    struct EVMFetchRequest {\n        IEVMVerifier verifier;\n        address target;\n        bytes32[] commands;\n        uint256 operationIdx;\n        bytes[] constants;\n    }\n\n    /**\n     * @dev Creates a request to fetch the value of multiple storage slots from a contract via CCIP-Read, possibly from\n     *      another chain.\n     *      Supports dynamic length values and slot numbers derived from other retrieved values.\n     * @param verifier An instance of a verifier contract that can provide and verify the storage slot information.\n     * @param target The address of the contract to fetch storage proofs for.\n     */\n    function newFetchRequest(\n        IEVMVerifier verifier,\n        address target\n    ) internal pure returns (EVMFetchRequest memory) {\n        bytes32[] memory commands = new bytes32[](MAX_COMMANDS);\n        bytes[] memory constants = new bytes[](MAX_CONSTANTS);\n        assembly {\n            mstore(commands, 0) // Set current array length to 0\n            mstore(constants, 0)\n        }\n        return EVMFetchRequest(verifier, target, commands, 0, constants);\n    }\n\n    /**\n     * @dev Starts describing a new fetch request.\n     *      Paths specify a series of hashing operations to derive the final slot ID.\n     *      See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html for details on how Solidity\n     *      lays out storage variables.\n     * @param request The request object being operated on.\n     * @param baseSlot The base slot ID that forms the root of the path.\n     */\n    function getStatic(\n        EVMFetchRequest memory request,\n        uint256 baseSlot\n    ) internal pure returns (EVMFetchRequest memory) {\n        bytes32[] memory commands = request.commands;\n        uint256 commandIdx = commands.length;\n        if (commandIdx > 0 && request.operationIdx < 32) {\n            // Terminate previous command\n            _addOperation(request, OP_END);\n        }\n        assembly {\n            mstore(commands, add(commandIdx, 1)) // Increment command array length\n        }\n        if (request.commands.length > MAX_COMMANDS) {\n            revert TooManyCommands(MAX_COMMANDS);\n        }\n        request.operationIdx = 0;\n        _addOperation(request, 0);\n        _addOperation(request, _addConstant(request, abi.encode(baseSlot)));\n        return request;\n    }\n\n    /**\n     * @dev Starts describing a new fetch request.\n     *      Paths specify a series of hashing operations to derive the final slot ID.\n     *      See https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html for details on how Solidity\n     *      lays out storage variables.\n     * @param request The request object being operated on.\n     * @param baseSlot The base slot ID that forms the root of the path.\n     */\n    function getDynamic(\n        EVMFetchRequest memory request,\n        uint256 baseSlot\n    ) internal pure returns (EVMFetchRequest memory) {\n        bytes32[] memory commands = request.commands;\n        uint256 commandIdx = commands.length;\n        if (commandIdx > 0 && request.operationIdx < 32) {\n            // Terminate previous command\n            _addOperation(request, OP_END);\n        }\n        assembly {\n            mstore(commands, add(commandIdx, 1)) // Increment command array length\n        }\n        if (request.commands.length > MAX_COMMANDS) {\n            revert TooManyCommands(MAX_COMMANDS);\n        }\n        request.operationIdx = 0;\n        _addOperation(request, FLAG_DYNAMIC);\n        _addOperation(request, _addConstant(request, abi.encode(baseSlot)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `uint256` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(\n        EVMFetchRequest memory request,\n        uint256 el\n    ) internal pure returns (EVMFetchRequest memory) {\n        if (request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, abi.encode(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `bytes32` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(\n        EVMFetchRequest memory request,\n        bytes32 el\n    ) internal pure returns (EVMFetchRequest memory) {\n        if (request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, abi.encode(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds an `address` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(\n        EVMFetchRequest memory request,\n        address el\n    ) internal pure returns (EVMFetchRequest memory) {\n        if (request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, abi.encode(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `bytes` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(\n        EVMFetchRequest memory request,\n        bytes memory el\n    ) internal pure returns (EVMFetchRequest memory) {\n        if (request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, el));\n        return request;\n    }\n\n    /**\n     * @dev Adds a `string` element to the current path.\n     * @param request The request object being operated on.\n     * @param el The element to add.\n     */\n    function element(\n        EVMFetchRequest memory request,\n        string memory el\n    ) internal pure returns (EVMFetchRequest memory) {\n        if (request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        _addOperation(request, _addConstant(request, bytes(el)));\n        return request;\n    }\n\n    /**\n     * @dev Adds a reference to a previous fetch to the current path.\n     * @param request The request object being operated on.\n     * @param idx The index of the previous fetch request, starting at 0.\n     */\n    function ref(\n        EVMFetchRequest memory request,\n        uint8 idx\n    ) internal pure returns (EVMFetchRequest memory) {\n        if (request.operationIdx >= 32) {\n            revert CommandTooLong();\n        }\n        if (idx > request.commands.length || idx > 31) {\n            revert InvalidReference(idx, request.commands.length);\n        }\n        _addOperation(request, OP_BACKREF | idx);\n        return request;\n    }\n\n    /**\n     * @dev Initiates the fetch request.\n     *      Calling this function terminates execution; clients that implement CCIP-Read will make a callback to\n     *      `callback` with the results of the operation.\n     * @param callbackId A callback function selector on this contract that will be invoked via CCIP-Read with the result of the lookup.\n     *        The function must have a signature matching `(bytes[] memory values, bytes callbackData)` with a return type matching the call in which\n     *        this function was invoked. Its return data will be returned as the return value of the entire CCIP-read operation.\n     * @param callbackData Extra data to supply to the callback.\n     */\n    function fetch(\n        EVMFetchRequest memory request,\n        bytes4 callbackId,\n        bytes memory callbackData\n    ) internal view {\n        if (request.commands.length > 0 && request.operationIdx < 32) {\n            // Terminate last command\n            _addOperation(request, OP_END);\n        }\n\n        revert OffchainLookup(\n            address(this),\n            request.verifier.gatewayURLs(),\n            abi.encodeCall(\n                IEVMGateway.getStorageSlots,\n                (request.target, request.commands, request.constants)\n            ),\n            EVMFetchTarget.getStorageSlotsCallback.selector,\n            abi.encode(\n                request.verifier,\n                request.commands,\n                request.constants,\n                callbackId,\n                callbackData\n            )\n        );\n    }\n\n    function _addConstant(\n        EVMFetchRequest memory request,\n        bytes memory value\n    ) private pure returns (uint8 idx) {\n        bytes[] memory constants = request.constants;\n        idx = uint8(constants.length);\n        assembly {\n            mstore(constants, add(idx, 1)) // Increment constant array length\n        }\n        constants[idx] = value;\n    }\n\n    function _addOperation(\n        EVMFetchRequest memory request,\n        uint8 op\n    ) private pure {\n        uint256 commandIdx = request.commands.length - 1;\n        request.commands[commandIdx] =\n            request.commands[commandIdx] |\n            (bytes32(bytes1(op)) >> (8 * request.operationIdx++));\n    }\n}\n"
    },
    "contracts/linea-verifier/EVMFetchTarget.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {IEVMVerifier} from \"./IEVMVerifier.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev Callback implementation for users of `EVMFetcher`. If you use `EVMFetcher`, your contract must\n *      inherit from this contract in order to handle callbacks correctly.\n */\nabstract contract EVMFetchTarget {\n    using Address for address;\n\n    error ResponseLengthMismatch(uint256 actual, uint256 expected);\n\n    /**\n     * @dev Internal callback function invoked by CCIP-Read in response to a `getStorageSlots` request.\n     */\n    function getStorageSlotsCallback(\n        bytes calldata response,\n        bytes calldata extradata\n    ) external {\n        bytes memory proof = abi.decode(response, (bytes));\n        (\n            IEVMVerifier verifier,\n            bytes32[] memory commands,\n            bytes[] memory constants,\n            bytes4 callback,\n            bytes memory callbackData\n        ) = abi.decode(\n                extradata,\n                (IEVMVerifier, bytes32[], bytes[], bytes4, bytes)\n            );\n        bytes[] memory values = verifier.getStorageValues(\n            commands,\n            constants,\n            proof\n        );\n        if (values.length != commands.length) {\n            revert ResponseLengthMismatch(values.length, commands.length);\n        }\n        bytes memory ret = address(this).functionCall(\n            abi.encodeWithSelector(callback, values, callbackData)\n        );\n        assembly {\n            return(add(ret, 32), mload(ret))\n        }\n    }\n}\n"
    },
    "contracts/linea-verifier/IEVMVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ninterface IEVMVerifier {\n    function gatewayURLs() external view returns (string[] memory);\n\n    function getStorageValues(\n        bytes32[] memory commands,\n        bytes[] memory constants,\n        bytes memory proof\n    ) external view returns (bytes[] memory values);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}